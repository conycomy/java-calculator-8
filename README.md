# java-calculator-precourse
# 문자열 덧셈 계산기

입력된 문자열을 구분자를 기준으로 분리하여 합계를 계산하는 프로그램입니다.  
절차지향적으로 기능을 완성한 뒤, 객체지향 원칙에 따라 리팩토링하며 구조를 개선했습니다.

---

## 미션 개요

- 우아한테크코스 프리코스 1주차 과제  
- 문자열 입력을 받아 구분자 기준으로 숫자를 분리하고, 합을 계산하는 프로그램  
- 기본 구분자( `,` , `:` )와 커스텀 구분자(`//;\n`) 모두 지원  
- 잘못된 입력(음수, 문자 등)에 대해 예외 발생

---

## 기능 요구사항

- 입력된 문자열에서 숫자를 추출하여 덧셈 결과를 반환한다.  
- 기본 구분자(쉼표 `,` , 콜론 `:`)를 사용한다.  
- 커스텀 구분자를 지정할 수 있다. (예: `//;\n1;2;3`)  
- 잘못된 입력(문자, 음수, 공백 등)은 `IllegalArgumentException`을 발생시킨다.

---

## 구현 단계별 정리

이 프로젝트는 **절차지향적으로 구현한 뒤**,  
**리팩토링을 통해 객체지향적으로 개선한 과정**을 담고 있습니다.  
핵심 로직을 세분화하고, 역할에 따라 클래스를 분리하며 점진적으로 구조를 발전시켰습니다.

---

### 1단계: 핵심 로직 구현 (절차지향 → 기능 분리)

- 문자열을 입력받아 구분자 기준으로 분리하고, 숫자를 더하는 기본 기능 구현  
- 커스텀 구분자(`//;\n`) 처리 및 음수 검증 등 비즈니스 규칙을 절차적으로 구현  
- 기능 단위로 메서드를 분리하여 테스트 용이성 확보

---

### 2단계: 구조화 및 객체지향 리팩토링

Application / InputHandler: 사용자 I/O 처리 및 모든 객체를 조립하여 계산 흐름을 실행합니다. (조립 및 I/O 분리)

Calculator (I): calculate(String input) 메서드로 계산 행위의 규약을 정의합니다. (최상위 규약)

ValidationStrategy (I): 검증 로직의 규약을 정의하며, StringCalculator가 검증 방식을 유연하게 바꿀 수 있게 합니다. (전략 패턴 인터페이스)

StringCalculator: 모든 구성 요소를 주입받아 순차적으로 호출하며 계산 흐름을 총괄하고, 오직 숫자 합산 책임만 가집니다. (지휘자/서비스)

CollectAllValidator: ValidationStrategy를 구현하여, 모든 음수를 수집하고 한 번에 예외를 던지는 복잡한 검증 전략을 수행합니다. (검증 전략 구현체)

DefaultDelimiterParser: 입력 문자열을 분석하여 **구분자 정보(DelimiterInfo)**와 숫자 문자열을 추출합니다. (\r 문자 정규화 처리 포함) (분석 전문가)

DelimiterInfo (DTO): 구분자 정규식 및 숫자 문자열을 담는 데이터 전달 객체입니다. (데이터 홀더)

NumberParser: 개별 토큰을 BigInteger로 변환하고 NumberFormatException을 처리합니다. (변환 전문가)의

--- 
## 예외 상황

- 문자가 포함된 입력값 (예: `"a,2,3"`, `"1b:4"`)  
- 음수 입력값 (예: `"-1,2,3"`)  
- 구분자가 연속된 경우 (예: `"1,,2"`)  
- 소수 입력 (예: `"1.5,2"`)  
- 빈 문자열 또는 공백 입력 (예: `""`, `" "`)  
- `null` 또는 입력이 존재하지 않는 경우  
- 숫자만 단독 입력된 경우

---

## 미션 진행 방향

이 미션은 **절차지향적으로 작동하는 코드를 먼저 작성한 뒤**,  
객체지향 원칙(OOP)에 따라 **역할과 책임 중심으로 구조를 개선**하는 것을 목표로 합니다.

1. 절차지향적으로 기능을 완성한다.  
2. 역할과 책임을 분리하여 구조를 개선한다.  
3. 테스트 가능한 구조로 리팩토링한다.

---

## 커밋 컨벤션

AngularJS Commit Message 규칙을 참고했습니다.  
커밋은 **기능 단위**로 나누어 작성합니다. (예: 기본 구분자 처리, 커스텀 구분자 추가, 음수 예외 처리 등)

**Allowed `<type>`**

- feat: 새로운 기능 추가  
- fix: 버그 수정  
- docs: 문서 수정  
- style: 코드 포맷팅  
- refactor: 코드 리팩토링  
- test: 테스트 코드 추가  
- chore: 빌드, 설정 등 유지보수 작업  

> 콜론(`:`) 뒤에는 반드시 공백 한 칸을 둡니다.

---

## 어떤 점에 집중했는가

- 절차지향적 설계로 기본 동작 완성 능력 향상  
- 예외 처리와 입력 검증을 체계적으로 구현  
- 객체지향적 리팩토링을 통한 책임 분리 연습  
- 클린 코드 원칙을 적용하고 유지보수성을 고려한 설계

---

## 요약

이 프로젝트는 문자열 계산기를 절차지향적으로 구현한 뒤,  
객체지향 설계 원칙에 따라 구조를 개선하며 **깨끗하고 확장 가능한 코드**로 발전시키는 과정을 담고 있습니다.

--- 
과제 소감 및 회고

이번 과제를 진행하며 처음에는 절차지향적으로 구현을 한 뒤, 점차 리팩토링을 통해 설계를 개선하는 과정을 보여주고 싶었습니다. 초기에는 차례대로 기능을 구현하는 데 집중했지만, 리드미에 추가된 새로운 모듈들이 등장하면서 예상치 못한 상황에 당황하기도 했습니다. 이를 통해 구현 과정에서 수정 가능성을 감안한 설계의 중요성을 깨달았습니다.

특히 객체지향 설계 패턴을 적용하면서, StringCalculator가 모든 책임을 지는 구조에서 CollectAllValidator와 같은 전략 구현체로 책임을 위임하는 전략 패턴에 익숙해지는 데 시간이 필요했습니다. 이를 통해 인터페이스의 본질과 조립의 책임을 체감할 수 있었습니다.

또한, 우테코 미션에서는 기능 구현만큼이나 요구사항에 명시된 출력 형식이 중요함을 배웠습니다. 최종 실패 원인이 논리적 오류가 아닌 띄어쓰기 불일치였다는 점에서 출력 형식의 중요성을 절실히 느꼈습니다. 이번 과제에서는 System.out.print()로 직접 확인하던 방식 대신 단위 테스트와 통합 테스트를 통해 안정성을 검증하며, 테스트 코드 작성의 중요성과 오류를 찾아가는 과정의 즐거움도 경험할 수 있었습니다.

환경 독립적인 코드 작성의 중요성도 깨달았습니다. DefaultDelimiterParser에서 \r 문자를 제거하여 운영체제나 테스트 환경의 사소한 차이에도 코드가 흔들리지 않도록 입력을 정규화한 경험이 그 예입니다.

마지막으로, 과제 수행 과정에서 겪은 고난과 역경은 코드 결과에는 그대로 드러나지 않았지만, 이를 커밋 메시지(feat, refactor, fix 등)로 기록하며 과정의 의미를 남기려 노력했습니다. 이번 경험을 통해 단순 구현을 넘어 설계, 테스트, 환경 고려, 기록까지 완성하는 과정을 배우게 되었으며, 다음 과제에서는 한층 더 발전된 나를 기대합니다.
